Linux Kernel Runtime Guard (LKRG)
=================================

LKRG performs runtime integrity checking of the Linux kernel and detection of
security vulnerability exploits against the kernel.

Being a kernel module (not a kernel patch), LKRG can be built for and loaded on
top of a wide range of mainline and distros' kernels, without needing to patch
those.  We currently support kernel versions ranging from as far back as
RHEL7's (and its many clones/revisions) and Ubuntu 16.04's to latest mainline
and distros' kernels.  For this release, we've tested LKRG with Linux kernels
up to and including 5.7.

Please refer to CONCEPTS for concepts behind LKRG and for information on its
efficacy, and to PERFORMANCE for information on its performance impact.

The following sections describe how to obtain LKRG sources, compile them, test
LKRG, install it on the system, and customize its configuration.


Getting the sources
-------------------

For LKRG releases and latest source code, please refer to its homepage:

	https://www.openwall.com/lkrg/

To download this release from there and verify it, you would have used commands
like the below:

	wget https://www.openwall.com/signatures/openwall-offline-signatures.asc
	gpg --import openwall-offline-signatures.asc
	wget https://www.openwall.com/lkrg/lkrg-0.8.tar.gz.sign
	wget https://www.openwall.com/lkrg/lkrg-0.8.tar.gz
	gpg --verify lkrg-0.8.tar.gz.sign lkrg-0.8.tar.gz

Please preserve the GnuPG key above and also use it to verify future releases,
which will most likely work in a similar manner.

Latest LKRG development source code is hosted on Bitbucket, from where you can
clone the git repository to a local directory using the following command:

	git clone https://bitbucket.org/Adam_pi3/lkrg-main.git


Build requirements
------------------

To compile LKRG, you will need the following software:

- GNU make

- A C compiler (ideally, the same that was used to compile the kernel itself)

- A kernel build directory corresponding to the Linux kernel image the module
  is to run on.  For example, under Debian and Ubuntu each linux-image package
  containing a kernel binary has a corresponding linux-headers package with the
  required build infrastructure, which you can install with:

	sudo apt-get install linux-headers-$(uname -r)

  Red Hat'ish (e.g. RHEL, CentOS, Fedora) distributions call this package
  kernel-devel, which you can install with:

	sudo yum install kernel-devel

(For documentation purposes, we prefix commands requiring root access with
"sudo", but you may of course run them as root by different means.)


Compiling
---------

With the above requirements satisfied, you should be able to easily compile
LKRG by running "make" when you're in LKRG's top level source code directory.
Compiling LKRG does not require root, and thus shouldn't be done as root.

To speed up the building, we recommend specifying a parallel job count matching
your machine's logical CPU count, e.g. like this:

	make -j8


Testing
-------

We recommend that before you install LKRG on the system such that it would be
started on bootup, you test loading of the LKRG module into the kernel manually
without making that setup permanent yet.  We also recommend that you keep
LKRG's detection of kernel integrity violations enabled for this test, yet
change its enforcement action from kernel panic (the default) to mere logging.
This way, you can safely detect potential system-specific false positives and
only proceed with installation if there are none.

You can do this for a freshly built LKRG (and while you're still in its top
level source code directory) with the following command:

	sudo insmod output/p_lkrg.ko kint_enforce=1

Then check kernel messages for any potential errors, use the system for a long
while, and check again:

	sudo dmesg

(Depending on kernel version and system configuration, the "dmesg" command
might not require root.)

Unload LKRG from the kernel with:

	sudo rmmod p_lkrg

so that it can then be loaded using the same procedure that's used on system
bootup and without the parameter override.


Installation
------------

If your Linux distribution uses systemd, you can install LKRG with:

	sudo make install

while you're still in its top level source code directory.

Run the following command to start the LKRG service just like it would be
started on next system bootup:

	sudo systemctl start lkrg

You can uninstall LKRG using "make" as well (still in the same directory):

	sudo make uninstall

In fact, you would need to do this before installing a new version of LKRG.

You can also use the following command to temporarily stop the LKRG service
without uninstalling it:

	sudo systemctl stop lkrg

We don't in any way favor systemd over other init systems, and would gladly add
support for those as well if there's demand or especially if we receive such
contributions.  Meanwhile, on a system without systemd you can let "sudo make
install" partially complete (up to the point where it finds you're not using
systemd) and then use:

	sudo modprobe p_lkrg

to load the module.  You can also put the "modprobe p_lkrg" command into a
system startup script.


Module parameters
-----------------

The LKRG kernel module supports a number of parameters, including kint_enforce
already mentioned above and many more.

For freshly built LKRG, you can list the parameters with:

	modinfo output/p_lkrg.ko

while you're still in LKRG's top level source code directory.

With LKRG installed on the system, you can list them with:

	sudo modinfo p_lkrg

(Depending on system configuration, "modinfo" might not require root.)

Parameters can be specified on command-lines of "insmod", "modprobe", or in a
file in the /etc/modprobe.d directory.

For descriptions of the parameters and their default and possible values,
please refer to the following section.


Runtime configuration
---------------------

Besides the parameters optionally specified when loading the module into the
kernel, LKRG also supports a number of sysctl's, which can be used to adjust
its behavior when it is already loaded into the kernel.  For each feature that
is configurable at both load time and run time, we have a module parameter and
a sysctl of similar name (the module parameters lack the "lkrg." prefix, but
are otherwise the same), so the below documentation is usable for both.

To list all LKRG sysctl's and their current values, use:

	sudo sysctl -a | grep lkrg

The sysctl's are (with default values specified in braces):

- lkrg.heartbeat (0)
  Whether or not to print a heartbeat message ("System is clean!" or "Tasks are
  clean!" depending on other configuration), if allowed by log_level, whenever
  the global integrity routine is executed.  Allowed values are 0 (never) and 1
  (print the message if allowed by log_level).

- lkrg.interval (15)
  LKRG's timer interval for periodic execution of the global integrity routine,
  in seconds.  Allowed values are 5 to 1800.

- lkrg.trigger (N/A)
  Force LKRG to execute the global integrity routine right now.  If you set
  this to 1, the global integrity routine is immediately run and this sysctl is
  reset to 0.

- lkrg.log_level (3)
  LKRG's logging verbosity level.  Allowed values are from 0 to 4 for normal
  builds or from 0 to 6 for debugging builds.

  Values of 4 and higher are meant for debugging only and produce too verbose
  logging for production use.  Moreover, some messages logged at those high
  levels contain information useful for kernel vulnerability exploitation,
  making those log levels potentially mildly insecure (depending on other
  system configuration).

- lkrg.block_modules (0)
  Whether or not to block further loading of kernel modules.  Allowed values
  are 0 (no) and 1 (yes).

  This feature is meant primarily to prevent unintended user-triggered (or
  attacker-triggered) auto-loading of maybe-vulnerable modules provided in a
  distribution after all intended modules have already been loaded.  This
  feature is not effective (nor is meant to be) against attackers who already
  have root privileges and try to load a module explicitly (they could simply
  flip this setting or even unload LKRG first).

  Also relevant is the kernel's kernel.modules_disabled sysctl, which fully
  disables module loading until the system is rebooted.

- lkrg.hide (0)
  Whether or not LKRG should hide itself from the lists of loaded modules and
  KOBJs.  Allowed values are 0 (do not hide LKRG, or unhide it if previously
  hidden) and 1 (hide LKRG).

  Please note that LKRG can be easily detected by other means anyway, such as
  through the presence of its sysctl's.

- lkrg.msr_validate (1)
  Whether or not to validate CPU Model Specific Registers (MSRs) whenever the
  global integrity routine is executed.  This can only be enabled on x86(-64)
  CPUs.  Allowed values are 0 (do not validate MSRs) and 1 (validate MSRs).

  There are situations where such validation is undesirable, such as if you run
  LKRG on a host machine that manages VMs and dynamically reconfigures MSRs.
  This is known to be the case for KVM, VirtualBox, and VMware hosts, where
  you'd need to disable this setting.  However, there's no problem with keeping
  this setting enabled on Linux+LKRG guest systems in VMs on those hosts.

- lkrg.kint_validate (3)
  Whether and when to validate global kernel integrity.  Allowed values are 0
  (disabled), 1 (only when manually triggered by lkrg.trigger), 2 (also
  periodically every lkrg.interval seconds), and 3 (also periodically every
  lkrg.interval seconds and probabilistically on certain other events).

  This currently applies to kernel and modules code and read-only data, global
  SELinux settings, and some CPU status registers/bits (MSRs, WP, SMEP, SMAP).

- lkrg.kint_enforce (2)
  How to act on global kernel integrity violations.  Allowed values are 0 (log
  once and accept new likely-compromised state as valid), 1 (log only for most
  violations, log the violation and restore previous state for SELinux and CPU
  WP bit), and 2 (panic the kernel).

  Note that lkrg.kint_enforce=1 is expected to produce repeated log messages on
  most kernel integrity violations, which can be noisy.  Also note that
  lkrg.kint_enforce=2 is unfortunately the only way to make full use of LKRG's
  global kernel integrity validation.  Running with lkrg.kint_validate=2 or
  higher but lkrg.kint_enforce set to 0 or 1 wastes CPU time on costly checks
  without achieving a corresponding security improvement, except that it might
  provide logs for post-mortem detection and analysis of a security compromise.

  Also relevant is the kernel's kernel.panic sysctl and panic parameter, which
  makes the system reboot on kernel panic.  For example, kernel.panic=60 in
  /etc/sysctl.conf or in a file under the /etc/sysctl.d directory, or panic=60
  on the kernel's command-line, will make the system reboot in 60 seconds after
  a panic.  This provides a brief opportunity read the panic message on the
  console yet makes an unattended server try to come back up on its own.

- lkrg.pint_validate (2)
  Whether and when to validate process credentials integrity.  Allowed values
  are 0 (disabled), 1 (validate a task's credentials just before it'd make use
  of the credentials), 2 (also validate a task's credentials when it wakes up
  from sleep), and 3 (validate credentials of all tasks in the system whenever
  any task is about to make use of its credentials or wakes up).

  Except with lkrg.pint_validate=0, we also validate the credentials of all
  tasks as part of LKRG's global integrity routine.

  lkrg.pint_validate=1 is sufficient to provide most of LKRG's potential at
  timely detection of exploits, with higher settings providing only minuscule
  improvements.  lkrg.pint_validate=2's additional performance overhead is also
  minuscule, which is why we enable this by default.  lkrg.pint_validate=3 is a
  paranoid mode with high performance overhead for little security gain.

- lkrg.pint_enforce (1)
  How to act on process credentials integrity violations.  Allowed values are 0
  (log once and accept new likely-compromised state as valid), 1 (kill the
  task), and 2 (panic the kernel).

  In Linux kernel's terminology, which we also use here, a "task" refers to a
  thread, and threads of a program may technically have different credentials.
  Our enforcement of process credentials integrity is thus per-thread, and e.g.
  it might happen that we kill an individual compromised thread of a program.

- lkrg.pcfi_validate (2)
  Whether and to what extent to validate Control Flow Integrity (CFI) on kernel
  functions that we monitor because of their usefulness for exploits' Return
  Oriented Programming (ROP) chains.  Allowed values are 0 (disabled), 1 (only
  sanity-check the stack pointer), and 2 (also sanity-check all stack frames).

  Because of the very limited extent of validation performed, we call our CFI
  mechanism pCFI, for poor man's CFI.

  lkrg.pcfi_validate=2 is incompatible with VirtualBox hosts, where you need to
  use at most lkrg.pcfi_validate=1.  However, there's no problem with keeping
  lkrg.pcfi_validate=2 on Linux+LKRG guest systems in VirtualBox VMs.

- lkrg.pcfi_enforce (1)
  How to act on pCFI violations.  Allowed values are 0 (log only), 1 (kill the
  task), and 2 (panic the kernel).

  Note that lkrg.pcfi_enforce=0 may produce repeated log messages for the same
  violation, which might occasionally be noisy.

- lkrg.umh_validate (1)
  Whether and to what extent to validate uses of usermodehelper (UMH).  Allowed
  values are 0 (validation disabled), 1 (allow only previously known programs),
  and 2 (completely block UMH).

  UMH can also be protected with pCFI regardless of this setting.

  UMH is a kernel-internal interface, which the kernel uses to invoke programs
  such as /sbin/modprobe (to auto-load a module on demand) and many others.
  When left unrestricted, UMH is convenient for kernel vulnerability exploits.

- lkrg.umh_enforce (1)
  How to act on UMH usage violations.  Allowed values are 0 (log only), 1
  (prevent execution), and 2 (panic the kernel).

- lkrg.smep_validate (1)
  Whether or not to validate the Supervisor Mode Execution Protection (SMEP)
  bit on supporting x86-64 CPUs.  Allowed values are 0 (no) and 1 (yes).

- lkrg.smep_enforce (2)
  How to act on unexpected changes of the SMEP bit.  Allowed values are 0 (log
  once and accept new likely-compromised state as valid), 1 (log the violation
  and restore original value), and 2 (panic the kernel).

- lkrg.smap_validate (1)
  Whether or not to validate the Supervisor Mode Access Prevention (SMAP) bit
  on supporting x86-64 CPUs.  Allowed values are 0 (no) and 1 (yes).

- lkrg.smap_enforce (2)
  How to act on unexpected changes of the SMAP bit.  Allowed values are 0 (log
  once and accept new likely-compromised state as valid), 1 (log the violation
  and restore original value), and 2 (panic the kernel).

We do understand that we are providing a lot of knobs. To make configuration
easier and faster, we introduced 'profiles'. 'lkrg.profile_validate' controls
all '*_validate' knobs and 'lkrg.profile_enforce' controls all '*_enforce'.
By default 'lkrg.profile_validate' = 9 which means 'custom settings'. However,
it might take values between 0-4 (or 9).
By default 'lkrg.profile_enforce' = 9 which means 'custom settings'. However,
it might take values between 0-3 (or 9).

Profiles:

-> lkrg.profile_validate:

|============================================================================================|
|          0 (Disabled)           |        1 (Light)         |         2 (Balanced)          |
|=================================|==========================|===============================|
| -> kint_validate = 0 (Disabled) | 1 (Manual trigger only)  | 2 (Triggered by timer)        |
| -> pint_validate = 0 (Disabled) | 1 (Current task only)    | 2 (Current + waking up task)  |
| -> pcfi_validate = 0 (Disabled) | 1 (Weak pCFI)            | 1 (Weak pCFI)                 |
| ->  umh_validate = 0 (Disabled) | 1 (Allow specific paths) | 1 (Allow specific paths)      |
| ->  msr_validate = 0 (Disabled) | 0 (Disabled)             | 0 (Disabled)                  |
| -> smep_validate = 0 (Disabled) | 1 (Enabled)              | 1 (Enabled)                   |
| -> smap_validate = 0 (Disabled) | 1 (Enabled)              | 1 (Enabled)                   |
|============================================================================================|
|             3 (Moderate)                |                    4 (Heavy)                     |
|============================================================================================|
| 3 (Triggered by timer + random events)  | 3 (Triggered by timer + random events)           |
| 2 (Current + waking up task)            | 3 (Verify all tasks in the system by every hook) |
| 2 (Full pCFI)                           | 2 (Full pCFI)                                    |
| 1 (Allow specific paths)                | 2 (Full UMH lock-down)                           |
| 1 (Enabled)                             | 1 (Enabled)                                      |
| 1 (Enabled)                             | 1 (Enabled)                                      |
| 1 (Enabled)                             | 1 (Enabled)                                      |
|============================================================================================|

-> lkrg.profile_enforce:

|================================================================================|
|          0 (Log & Accept)          | 1 (Balanced)  | 2 (Moderate)  | 3 (Panic) |
|====================================|===============|===============|===========|
| -> kint_enforce = 0 (Log & accept) | 1 (Log only)  | 2 (Panic)     | 2 (Panic) |
| -> pint_enforce = 0 (Log & accept) | 1 (Kill task) | 1 (Kill task) | 2 (Panic) |
| -> pcfi_enforce = 0 (Log only)     | 1 (Kill task) | 1 (Kill task) | 2 (Panic) |
| ->  umh_enforce = 0 (Log only)     | 1 (Prev exec) | 1 (Prev exec) | 2 (Panic) |
| -> smep_enforce = 0 (Log & accept) | 2 (Panic)     | 2 (Panic)     | 2 (Panic) |
| -> smap_enforce = 0 (Log & accept) | 2 (Panic)     | 2 (Panic)     | 2 (Panic) |
|================================================================================|


That's all for now. Greetings from the LKRG team :)
